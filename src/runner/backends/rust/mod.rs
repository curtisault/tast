pub mod mapping;

use std::collections::HashMap;
use std::fmt::Write;
use std::path::{Path, PathBuf};

use crate::plan::types::{PlanStep, StepEntry, TestPlan};
use crate::runner::backend::{BackendError, BackendErrorKind, GeneratedHarness, TestBackend};
use crate::runner::context::RunContext;
use crate::runner::result::StepResult;

use self::mapping::resolve_mapping;

/// Rust test backend — generates and executes `cargo test` harnesses.
pub struct RustBackend {
    /// The cargo command to use (default: "cargo").
    pub cargo_command: String,
    /// Additional arguments passed to `cargo test`.
    pub test_args: Vec<String>,
    /// Directory for generated test files (default: temp dir).
    pub harness_dir: Option<PathBuf>,
}

impl RustBackend {
    pub fn new() -> Self {
        Self {
            cargo_command: "cargo".into(),
            test_args: Vec::new(),
            harness_dir: None,
        }
    }

    /// Generate a Rust test function body for a single plan step.
    pub(crate) fn generate_test_fn(&self, step: &PlanStep) -> String {
        let fn_name = to_snake_case(&step.node);
        let mut out = String::new();

        // Function signature
        writeln!(out, "    #[test]").unwrap();
        writeln!(out, "    fn test_{fn_name}() {{").unwrap();

        // Header comment
        writeln!(out, "        // Step {}: {}", step.order, step.node).unwrap();
        if let Some(desc) = &step.description {
            writeln!(out, "        // {desc}").unwrap();
        }
        writeln!(out).unwrap();

        // --- Given ---
        if !step.preconditions.is_empty() {
            writeln!(out, "        // --- Given ---").unwrap();
            for entry in &step.preconditions {
                write_step_entry(&mut out, entry);
            }
            writeln!(out).unwrap();
        }

        // --- When ---
        if !step.actions.is_empty() {
            writeln!(out, "        // --- When ---").unwrap();
            for entry in &step.actions {
                write_step_entry(&mut out, entry);
            }
            writeln!(out).unwrap();
        }

        // --- Then ---
        if !step.assertions.is_empty() {
            writeln!(out, "        // --- Then ---").unwrap();
            for entry in &step.assertions {
                write_step_entry(&mut out, entry);
            }
        }

        writeln!(out, "    }}").unwrap();
        out
    }

    /// Generate the full test file containing all step test functions.
    pub(crate) fn generate_test_file(&self, plan: &TestPlan) -> String {
        let mut out = String::new();

        // File header
        writeln!(out, "// Auto-generated by TAST \u{2014} do not edit").unwrap();
        writeln!(out, "// Plan: {}", plan.plan.name).unwrap();
        writeln!(out).unwrap();
        writeln!(out, "#[cfg(test)]").unwrap();
        writeln!(out, "mod tast_generated {{").unwrap();
        writeln!(out, "    use std::collections::HashMap;").unwrap();
        writeln!(out).unwrap();

        for step in &plan.steps {
            let test_fn = self.generate_test_fn(step);
            out.push_str(&test_fn);
            writeln!(out).unwrap();
        }

        writeln!(out, "}}").unwrap();
        out
    }
}

impl Default for RustBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl TestBackend for RustBackend {
    fn name(&self) -> &str {
        "rust"
    }

    fn detect_project(&self, path: &Path) -> bool {
        path.join("Cargo.toml").exists()
    }

    fn generate_harness(
        &self,
        plan: &TestPlan,
        context: &RunContext,
    ) -> Result<GeneratedHarness, BackendError> {
        let harness_dir = self
            .harness_dir
            .clone()
            .unwrap_or_else(|| context.working_dir().join("target").join("tast"));

        std::fs::create_dir_all(&harness_dir).map_err(|e| BackendError {
            kind: BackendErrorKind::HarnessGenerationFailed,
            message: "failed to create harness directory".into(),
            detail: Some(e.to_string()),
        })?;

        let test_file = harness_dir.join("tast_generated_test.rs");
        let content = self.generate_test_file(plan);

        std::fs::write(&test_file, &content).map_err(|e| BackendError {
            kind: BackendErrorKind::HarnessGenerationFailed,
            message: "failed to write test file".into(),
            detail: Some(e.to_string()),
        })?;

        Ok(GeneratedHarness {
            files: vec![test_file.clone()],
            entry_point: test_file,
            metadata: HashMap::new(),
        })
    }

    fn execute_step(
        &self,
        step: &PlanStep,
        _harness: &GeneratedHarness,
        _context: &mut RunContext,
    ) -> Result<StepResult, BackendError> {
        // Stub — full implementation in Part D
        Ok(StepResult::skipped(&step.node))
    }

    fn cleanup(&self, harness: &GeneratedHarness) -> Result<(), BackendError> {
        for file in &harness.files {
            if file.exists() {
                std::fs::remove_file(file).map_err(|e| BackendError {
                    kind: BackendErrorKind::CleanupFailed,
                    message: format!("failed to remove {}", file.display()),
                    detail: Some(e.to_string()),
                })?;
            }
        }
        Ok(())
    }
}

/// Write a single step entry (given/when/then/and/but) with its mapping.
fn write_step_entry(out: &mut String, entry: &StepEntry) {
    let mapping = resolve_mapping(&entry.text, &entry.step_type);

    // Step text as comment
    writeln!(out, "        // {}", entry.text).unwrap();

    // Data block if present
    if !entry.data.is_empty() {
        writeln!(
            out,
            "        let mut _data: HashMap<&str, &str> = HashMap::new();"
        )
        .unwrap();
        for (key, value) in &entry.data {
            let escaped_val = escape_rust_string(value);
            writeln!(out, "        _data.insert(\"{key}\", \"{escaped_val}\");").unwrap();
        }
    }

    // Generated code from mapping
    for line in mapping.code.lines() {
        if line.is_empty() {
            writeln!(out).unwrap();
        } else {
            writeln!(out, "        {line}").unwrap();
        }
    }
}

/// Convert a PascalCase or mixed-case node name to snake_case.
fn to_snake_case(name: &str) -> String {
    let mut result = String::with_capacity(name.len() + 4);
    for (i, ch) in name.chars().enumerate() {
        if ch.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(ch.to_ascii_lowercase());
    }
    result
}

/// Escape special characters for Rust string literals.
fn escape_rust_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::plan::types::{PlanMetadata, PlanStep, StepEntry, TestPlan};

    fn make_step_entry(step_type: &str, text: &str) -> StepEntry {
        StepEntry {
            step_type: step_type.into(),
            text: text.into(),
            data: vec![],
            parameters: vec![],
        }
    }

    fn make_step_entry_with_data(
        step_type: &str,
        text: &str,
        data: Vec<(String, String)>,
    ) -> StepEntry {
        StepEntry {
            step_type: step_type.into(),
            text: text.into(),
            data,
            parameters: vec![],
        }
    }

    fn make_plan_step(order: usize, node: &str) -> PlanStep {
        PlanStep {
            order,
            node: node.into(),
            description: Some(format!("Description of {node}")),
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![make_step_entry("given", "a user exists")],
            actions: vec![make_step_entry("when", "the user acts")],
            assertions: vec![make_step_entry("then", "something happens")],
            inputs: vec![],
            outputs: vec![],
        }
    }

    fn make_plan(name: &str, steps: Vec<PlanStep>) -> TestPlan {
        TestPlan {
            plan: PlanMetadata {
                name: name.into(),
                traversal: "topological".into(),
                nodes_total: steps.len(),
                edges_total: 0,
            },
            steps,
        }
    }

    #[test]
    fn rust_backend_name() {
        let backend = RustBackend::new();
        assert_eq!(backend.name(), "rust");
    }

    #[test]
    fn rust_backend_detect_project_with_cargo_toml() {
        let backend = RustBackend::new();
        // Our own project root
        assert!(backend.detect_project(Path::new(env!("CARGO_MANIFEST_DIR"))));
    }

    #[test]
    fn rust_backend_detect_project_without_cargo_toml() {
        let backend = RustBackend::new();
        assert!(!backend.detect_project(Path::new("/tmp")));
    }

    #[test]
    fn generate_test_fn_single_given() {
        let backend = RustBackend::new();
        let step = PlanStep {
            order: 1,
            node: "SetupUser".into(),
            description: None,
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![make_step_entry("given", "a registered user")],
            actions: vec![],
            assertions: vec![],
            inputs: vec![],
            outputs: vec![],
        };
        let output = backend.generate_test_fn(&step);
        assert!(output.contains("fn test_setup_user()"));
        assert!(output.contains("// --- Given ---"));
        assert!(output.contains("// a registered user"));
    }

    #[test]
    fn generate_test_fn_multiple_givens() {
        let backend = RustBackend::new();
        let step = PlanStep {
            order: 1,
            node: "Setup".into(),
            description: None,
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![
                make_step_entry("given", "a registered user"),
                make_step_entry("and", "the user has an active session"),
            ],
            actions: vec![],
            assertions: vec![],
            inputs: vec![],
            outputs: vec![],
        };
        let output = backend.generate_test_fn(&step);
        assert!(output.contains("// a registered user"));
        assert!(output.contains("// the user has an active session"));
    }

    #[test]
    fn generate_test_fn_with_data() {
        let backend = RustBackend::new();
        let step = PlanStep {
            order: 1,
            node: "Register".into(),
            description: None,
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![make_step_entry_with_data(
                "given",
                "a user with credentials",
                vec![
                    ("email".into(), "test@example.com".into()),
                    ("password".into(), "secure123".into()),
                ],
            )],
            actions: vec![],
            assertions: vec![],
            inputs: vec![],
            outputs: vec![],
        };
        let output = backend.generate_test_fn(&step);
        assert!(output.contains("_data.insert(\"email\", \"test@example.com\")"));
        assert!(output.contains("_data.insert(\"password\", \"secure123\")"));
    }

    #[test]
    fn generate_test_fn_with_when_then() {
        let backend = RustBackend::new();
        let step = PlanStep {
            order: 1,
            node: "LoginUser".into(),
            description: Some("User logs in".into()),
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![make_step_entry("given", "a registered user")],
            actions: vec![make_step_entry("when", "the user submits credentials")],
            assertions: vec![make_step_entry("then", "the system returns a token")],
            inputs: vec![],
            outputs: vec![],
        };
        let output = backend.generate_test_fn(&step);
        assert!(output.contains("// --- Given ---"));
        assert!(output.contains("// --- When ---"));
        assert!(output.contains("// --- Then ---"));
        assert!(output.contains("// the user submits credentials"));
        assert!(output.contains("// the system returns a token"));
    }

    #[test]
    fn generate_test_fn_with_and_but() {
        let backend = RustBackend::new();
        let step = PlanStep {
            order: 1,
            node: "Verify".into(),
            description: None,
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![],
            actions: vec![],
            assertions: vec![
                make_step_entry("then", "the account is created"),
                make_step_entry("and", "a confirmation email is sent"),
                make_step_entry("but", "no duplicate account exists"),
            ],
            inputs: vec![],
            outputs: vec![],
        };
        let output = backend.generate_test_fn(&step);
        assert!(output.contains("// the account is created"));
        assert!(output.contains("// a confirmation email is sent"));
        assert!(output.contains("// no duplicate account exists"));
    }

    #[test]
    fn generate_test_file_header() {
        let backend = RustBackend::new();
        let plan = make_plan("AuthFlow", vec![]);
        let output = backend.generate_test_file(&plan);
        assert!(output.contains("// Auto-generated by TAST"));
        assert!(output.contains("// Plan: AuthFlow"));
        assert!(output.contains("#[cfg(test)]"));
        assert!(output.contains("mod tast_generated {"));
        assert!(output.contains("use std::collections::HashMap;"));
    }

    #[test]
    fn generate_test_file_single_step() {
        let backend = RustBackend::new();
        let plan = make_plan("Simple", vec![make_plan_step(1, "OnlyStep")]);
        let output = backend.generate_test_file(&plan);
        assert!(output.contains("fn test_only_step()"));
        assert!(output.contains("// Step 1: OnlyStep"));
    }

    #[test]
    fn generate_test_file_multiple_steps() {
        let backend = RustBackend::new();
        let plan = make_plan(
            "Multi",
            vec![make_plan_step(1, "StepA"), make_plan_step(2, "StepB")],
        );
        let output = backend.generate_test_file(&plan);
        assert!(output.contains("fn test_step_a()"));
        assert!(output.contains("fn test_step_b()"));
    }

    #[test]
    fn generate_test_file_escapes_special_chars() {
        let backend = RustBackend::new();
        let step = PlanStep {
            order: 1,
            node: "Escape".into(),
            description: None,
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![make_step_entry_with_data(
                "given",
                "data with special chars",
                vec![("query".into(), "SELECT * FROM \"users\"".into())],
            )],
            actions: vec![],
            assertions: vec![],
            inputs: vec![],
            outputs: vec![],
        };
        let plan = make_plan("EscapeTest", vec![step]);
        let output = backend.generate_test_file(&plan);
        // The double quotes in the value should be escaped
        assert!(output.contains("\\\"users\\\""));
    }

    #[test]
    fn to_snake_case_converts_pascal() {
        assert_eq!(to_snake_case("RegisterUser"), "register_user");
        assert_eq!(to_snake_case("A"), "a");
        assert_eq!(to_snake_case("LoginUser"), "login_user");
        assert_eq!(to_snake_case("AccessDashboard"), "access_dashboard");
    }

    #[test]
    fn escape_rust_string_handles_specials() {
        assert_eq!(escape_rust_string(r#"a "b" c"#), r#"a \"b\" c"#);
        assert_eq!(escape_rust_string("a\\b"), "a\\\\b");
        assert_eq!(escape_rust_string("line1\nline2"), "line1\\nline2");
    }

    // -- C3: Harness validation tests --

    #[test]
    fn generated_harness_is_valid_rust_syntax() {
        let backend = RustBackend::new();
        let plan = make_plan(
            "Validation",
            vec![make_plan_step(1, "StepA"), make_plan_step(2, "StepB")],
        );
        let output = backend.generate_test_file(&plan);
        // Must have balanced braces
        let opens = output.chars().filter(|&c| c == '{').count();
        let closes = output.chars().filter(|&c| c == '}').count();
        assert_eq!(opens, closes, "unbalanced braces in generated code");
        // Must have module and test function structure
        assert!(output.contains("mod tast_generated {"));
        assert!(output.contains("#[test]"));
        assert!(output.contains("fn test_"));
    }

    #[test]
    fn generated_harness_includes_all_plan_steps() {
        let backend = RustBackend::new();
        let plan = make_plan(
            "AllSteps",
            vec![
                make_plan_step(1, "Alpha"),
                make_plan_step(2, "Beta"),
                make_plan_step(3, "Gamma"),
            ],
        );
        let output = backend.generate_test_file(&plan);
        assert!(output.contains("fn test_alpha()"));
        assert!(output.contains("fn test_beta()"));
        assert!(output.contains("fn test_gamma()"));
        // Each step should have its order comment
        assert!(output.contains("// Step 1: Alpha"));
        assert!(output.contains("// Step 2: Beta"));
        assert!(output.contains("// Step 3: Gamma"));
    }

    #[test]
    fn generated_harness_data_block_values_escaped() {
        let backend = RustBackend::new();
        let step = PlanStep {
            order: 1,
            node: "DataTest".into(),
            description: None,
            tags: vec![],
            depends_on: vec![],
            preconditions: vec![make_step_entry_with_data(
                "given",
                "data with tricky values",
                vec![
                    ("path".into(), "C:\\Users\\test".into()),
                    ("msg".into(), "say \"hello\"".into()),
                    ("multiline".into(), "line1\nline2".into()),
                ],
            )],
            actions: vec![],
            assertions: vec![],
            inputs: vec![],
            outputs: vec![],
        };
        let plan = make_plan("EscapeValidation", vec![step]);
        let output = backend.generate_test_file(&plan);
        // Backslashes doubled
        assert!(output.contains("C:\\\\Users\\\\test"));
        // Quotes escaped
        assert!(output.contains("say \\\"hello\\\""));
        // Newlines escaped
        assert!(output.contains("line1\\nline2"));
    }

    #[test]
    fn generated_harness_writes_to_disk() {
        let backend = RustBackend::new();
        let plan = make_plan("DiskTest", vec![make_plan_step(1, "WriteStep")]);

        let dir = std::env::temp_dir().join("tast_test_harness");
        let _ = std::fs::remove_dir_all(&dir);

        let mut backend_with_dir = RustBackend::new();
        backend_with_dir.harness_dir = Some(dir.clone());

        let ctx = RunContext::new(std::env::temp_dir());
        let harness = backend_with_dir.generate_harness(&plan, &ctx).unwrap();

        assert!(harness.entry_point.exists());
        let content = std::fs::read_to_string(&harness.entry_point).unwrap();
        assert!(content.contains("fn test_write_step()"));

        // Cleanup
        backend_with_dir.cleanup(&harness).unwrap();
        assert!(!harness.entry_point.exists());

        let _ = std::fs::remove_dir_all(&dir);
    }
}
